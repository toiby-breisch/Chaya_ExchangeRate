"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
exports.generate = exports.getSalt = exports.getPattern = exports.randomFromArray = void 0;
var crypto_extra_1 = __importDefault(require("crypto-extra"));
var index_1 = require("./index");
var Word;
(function (Word) {
    Word["Adjective"] = "adjectives";
    Word["Noun"] = "nouns";
    Word["Verb"] = "verbs";
})(Word || (Word = {}));
function randomFromArray(arr) {
    return arr[crypto_extra_1["default"].randomNumber({ max: arr.length - 1 })];
}
exports.randomFromArray = randomFromArray;
function getPattern(count) {
    switch (count) {
        case 0:
            return [];
        case 1:
            return randomFromArray([[Word.Adjective], [Word.Noun], [Word.Verb]]);
        case 3:
            return [Word.Adjective, Word.Noun, Word.Verb];
        case 4:
            return [Word.Adjective, Word.Noun, Word.Noun, Word.Verb];
        case 2:
        default:
            return randomFromArray([
                [Word.Adjective, Word.Noun],
                [Word.Noun, Word.Verb],
            ]);
    }
}
exports.getPattern = getPattern;
function getSalt(saltType, length) {
    var charset;
    if (saltType === "number") {
        console.warn("namor.genSalt(): saltType `number` has been deprecated, use `numbers` instead");
        saltType = "numbers";
    }
    if (saltType === "string") {
        console.warn("namor.genSalt(): saltType `string` has been deprecated, use `letters` instead");
        saltType = "letters";
    }
    switch (saltType) {
        case "numbers":
            charset = "0123456789";
            break;
        case "letters":
            charset = "abcdefghijklmnopqrstuvwxyz";
            break;
        case "mixed":
        default:
            charset = "abcdefghijklmnopqrstuvwxyz0123456789";
    }
    return crypto_extra_1["default"].randomString(length, charset);
}
exports.getSalt = getSalt;
function generate(opts) {
    if (opts === void 0) { opts = {}; }
    if (opts.saltLength) {
        console.warn("namor.generate(): `saltLength` option has been deprecated, use `salt` instead");
        opts.salt = opts.saltLength;
    }
    if (opts.subset) {
        console.warn("namor.generate(): `subset` option has been deprecated, use `dictionary` instead");
        opts.dictionary = opts.subset;
    }
    if (opts.saltType === "number") {
        console.warn("namor.generate(): saltType `number` has been deprecated, use `numbers` instead");
        opts.saltType = "numbers";
    }
    if (opts.saltType === "string") {
        console.warn("namor.generate(): saltType `string` has been deprecated, use `letters` instead");
        opts.saltType = "letters";
    }
    if (opts.dictionary === "manly") {
        console.warn("namor.generate(): The `manly` dictionary has been renamed to `rugged` instead");
        opts.dictionary = "rugged";
    }
    if (opts.words && (opts.words < 1 || opts.words > 4)) {
        throw new TypeError("Word count must be between 1-4");
    }
    opts.separator = opts.separator || "-";
    opts.words = Number(opts.words !== undefined ? opts.words : 2);
    opts.salt = Number(opts.salt !== undefined ? opts.salt : 0);
    opts.saltType = opts.saltType || "mixed";
    var salt = opts.salt > 0 ? getSalt(opts.saltType, opts.salt) : null;
    var dictionary = typeof opts.dictionary === "object" && opts.dictionary !== null
        ? opts.dictionary
        : opts.dictionary
            ? index_1.dictionaries[opts.dictionary]
            : index_1.dictionaries["default"];
    return getPattern(opts.words)
        .map(function (type) { return randomFromArray(dictionary[type]); })
        .concat([salt])
        .filter(Boolean)
        .join(opts.separator);
}
exports.generate = generate;
